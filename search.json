[
  {
    "objectID": "export_python.html",
    "href": "export_python.html",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "",
    "text": "This document showcases a basic Matlab script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_python.py."
  },
  {
    "objectID": "export_python.html#mockup-input-data",
    "href": "export_python.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe Python library h5py provides a convenient object-oriented interface to save python objects in the required HDF5 structure, so we don’t need particular care to organise them on the Python side.\n\nimport numpy as np\nimport os, sys\nimport h5py\n#possibly multiple wavelengths\nwavelength  = np.arange(400,850, 50)\nNl = len(wavelength)\nlmax = 3\nqmax = 2*(lmax*(lmax+1)+lmax)\n# dummy 30x30 matrix values repeated for each wavelength\ntdata = np.reshape(np.arange(1,901,1) + 1j*np.arange(1,901,1), (qmax,qmax))\ntmatrix = np.zeros((Nl,qmax,qmax), dtype=\"complex\")\nfor i in range(Nl):\n  tmatrix[i,:,:] = tdata\n\nprint(tmatrix[0,0:3,0:3])\n\nl = np.zeros(qmax)\nm = np.zeros(qmax)\ns = np.array([b'xxxxxxic']*len(l))\ni=0\nfor li in range(1,lmax+1):\n    for mi in range(-li, li+1):\n        for si in [b'electric', b'magnetic']:\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1"
  },
  {
    "objectID": "export_python.html#saving-to-hdf5",
    "href": "export_python.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe Python library h5py provides a convenient interface to generate groups, datasets, and attributes with simple assigments:\n\n# Saving to HDF5\nf = 'ap.tmat.h5';\nwith h5py.File(f, \"w\") as f:\n    f[\"vacuum_wavelength\"] = np.asarray(wavelength)\n    f[\"vacuum_wavelength\"].attrs[\"unit\"] = \"nm\"\n    f[\"tmatrix\"] = tmatrix\n    f['modes/l'] = l\n    f['modes/m'] = m\n    f['modes/polarization'] = s\n    emb = f.create_group(f\"embedding\")\n    emb[\"relative_permittivity\"] = 1.33**2\n    emb[\"relative_permeability\"] = 1.0\n    emb.attrs[\"name\"] = \"H2O, Water\"\n    emb.attrs[\"keywords\"] = \"non-dispersive\"\n    sca_mat = f.create_group(\"scatterer/material\")\n    sca_mat.attrs[\"name\"] = 'Au, Gold'\n    sca_mat.attrs[\"keywords\"] = \"dispersive, plasmonic\"\n    sca_mat.attrs[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n    sca_mat[\"relative_permittivity\"] = np.ones(len(wavelength), dtype = complex)*(-11.4+1.181j)\n    sca_mat[\"relative_permeability\"] = 1.0\n    sca_gr = f.create_group(\"scatterer/geometry\")\n    sca_gr[\"radiusxy\"] = 20.0\n    sca_gr[\"radiusz\"] = 40.0\n    sca_gr.attrs['unit'] = 'nm'\n    sca_gr.attrs['shape'] = 'spheroid'\n    sca_gr.attrs['name'] = 'homogeneous spheroid with symmetry axis z'\n    mpar = f.create_group(\"computation/method_parameters\")\n    #f[\"computation/analytical_zeros\"] = analytical_zeros # not needed in this example\n    mpar[\"Lmax\"] = lmax\n    mpar[\"Ntheta\"] = 100\n    f.create_group(\"computation/files\")\n    with open(__file__, \"r\") as scriptfile:\n        f[f\"computation/files/{os.path.basename(__file__)}\"] = scriptfile.read()\n    f[\"computation\"].attrs[\"method\"] = \"EBCM, Extended Boundary Condition Method\" \n    f[\"computation\"].attrs[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\" \n    f[\"computation\"].attrs[\"software\"] = f\"SMARTIES=1.1, python={sys.version.split()[0]}, h5py={h5py.__version__}\"\n    f[\"computation\"].attrs[\"name\"] = \"SMARTIES\"\n    f.attrs['name'] = 'Au prolate spheroid in water'\n    f.attrs['keywords'] = 'gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz'\n    f.attrs['description'] = 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids'\n    f.attrs['storage_format_version'] = 'v0.01'    \n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─export_python.py: \"import numpy as np↵import os, sy...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;dbl [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;dbl [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;int [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ └─software: \"SMARTIES=1.1, python=3.11.7, h5p...\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  },
  {
    "objectID": "export_R.html",
    "href": "export_R.html",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "",
    "text": "This document showcases a basic R script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_R.R."
  },
  {
    "objectID": "export_R.html#mockup-input-data",
    "href": "export_R.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe rhdf5 package has support for a variety of R objects, including lists which are automatically written as grouped objects in HDF5.\n\nlibrary(rhdf5) # note: dev version to support complex\nlibrary(uuid) # uuid\nlibrary(glue) # string interpolation\nlibrary(purrr) # mapping functions\n\n## dummy data\n\n# possibly multiple wavelengths\nwavelength &lt;- seq(400, 800, by=50)\nNl &lt;- length(wavelength)\n\nLmax &lt;- 3\nqmax &lt;- 2*(Lmax*(Lmax+1)+Lmax) # T-matrix size\n\n# dummy 30x30 matrix values for each wavelength\n# note the byrow due to HDF5 expecting\n# row-major ordering vs R's default column-major\ntdata &lt;- matrix(1:qmax^2 + 1i*(1:qmax^2), qmax, qmax, byrow=TRUE)\n\ntmatrix &lt;- array(NA_complex_, c(Nl,qmax,qmax))\nfor(i in seq_len(Nl))\n  tmatrix[i,,] &lt;- tdata\n\ntmatrix[1,1:3,1:3]\n\nmodes &lt;- list(l = rep(NA_integer_, qmax),\n              m = rep(NA_integer_, qmax),\n              polarization = rep(NA_character_, qmax))\n\ni &lt;- 1\nfor (li in 1:Lmax){\n  for (mi in -li:li){\n    for (si in c(\"electric\", \"magnetic\")){\n      modes$l[i] &lt;- li\n      modes$m[i] &lt;- mi\n      modes$polarization[i] &lt;- si\n      i &lt;-  i+1\n    }\n  }\n}\n\nembedding &lt;- list('relative_permeability' = 1.0, \n                  'relative_permittivity' = 1.33^2)\nscatterer &lt;- list(material = list('relative_permeability' = 1.0, \n                                  'relative_permittivity' =\n                                    rep(-11.4+1.181i,Nl)),\n                  geometry = list('radiusxy' = 20.0, \n                                  'radiusz' = 40.0))\n\ncomputation &lt;- list(method_parameters = list('Lmax' = Lmax, \n                                             'Ntheta' = 100),\n                    files = list(script = paste(readLines('export_R.R'), collapse = \"\\n\")))"
  },
  {
    "objectID": "export_R.html#saving-to-hdf5",
    "href": "export_R.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe rhdf5 package provides support for reading/writing HDF5 files into/from R objects. Until my recent request, complex arrays were not supported, but this is now implemented in the dev version of the package.\n\nlibrary(rhdf5) # note: requires dev version to support complex arrays\n# cf https://support.bioconductor.org/p/9156305/#9156408\n# install.packages(\"remotes\")\n# remotes::install_github(\"grimbough/rhdf5@devel\")\n# may need 'crypto' library from openSSL to compile\n# e.g. via brew install openssl on macos\n\nWe can then write the different objects defined above using hwrite. Note the important native = TRUE parameter for the T-matrix data: R stores arrays column-wise, while HDF5 uses row-major ordering. To avoid confusion between different programming languages, we suggest sticking with the native HDF5 convention (native = TRUE ensures that the array is written transposed).\nAttributes don’t seem to have a convenient high-level interface, and unfortunately they need to be written slightly differently for the root level, datasets, and groups.\n\nf &lt;- 'ar.tmat.h5'\nsoftware = sprintf(\"SMARTIES=1.1, R=%s, rhdf5=%s\", paste0(R.version$major, R.version$minor), packageVersion(\"rhdf5\"))\n\nunlink(f) # delete previous file if it exists\nh5createFile(f)\nh5closeAll() # in case connections open\n\nh5write(wavelength, file=f, name=\"/vacuum_wavelength\")\n\nh5write(tmatrix, file=f, name=\"/tmatrix\", native=TRUE) # store rowwise\n\nh5write(modes, file=f, name='/modes')\nh5write(embedding, file=f, name=\"/embedding\")\nh5write(scatterer, file=f, name=\"/scatterer\")\nh5write(computation, file=f, name='/computation')\n\n## write attributes\nfid &lt;- H5Fopen(f)\n# root level\nh5writeAttribute(\"Au prolate spheroid in water\", fid, \"name\")\nh5writeAttribute(\"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\", fid, \"description\")\nh5writeAttribute(\"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\", fid, \"keywords\")\nh5writeAttribute(\"v0.01\", fid, \"storage_format_version\")\n\n# wavelength\ndid &lt;- H5Dopen(fid, \"vacuum_wavelength\")\nh5writeAttribute(\"nm\", did, \"unit\")\nH5Dclose(did)\n\n# embedding\ngid &lt;- H5Gopen(fid, \"embedding\")\nh5writeAttribute(\"H2O, Water\", gid, \"name\")\nh5writeAttribute(\"non-dispersive\", gid, \"keywords\")\nH5Gclose(gid)\n\n# material\ngid &lt;- H5Gopen(fid, \"scatterer/material\")\nh5writeAttribute(\"Au, Gold\", gid, \"name\")\nh5writeAttribute(\"dispersive, plasmonic\", gid, \"keywords\")\nh5writeAttribute(\"Au from Raschke et al 10.1103/PhysRevB.86.235147\", gid, \"reference\")\nH5Gclose(gid)\n\n# geometry\ngid &lt;- H5Gopen(fid, \"scatterer/geometry\")\nh5writeAttribute(\"nm\", gid, \"unit\")\nh5writeAttribute(\"spheroid\", gid, \"shape\")\nh5writeAttribute(\"homogeneous spheroid with symmetry axis z\", gid, \"name\")\nH5Gclose(gid)\n\n# computation\ngid &lt;- H5Gopen(fid, \"computation\")\nh5writeAttribute(\"EBCM, Extended Boundary Condition Method\", gid, \"method\")\nh5writeAttribute(\"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\", gid, \"description\")\nh5writeAttribute(software, gid, \"software\")\nh5writeAttribute(\"SMARTIES\", gid, \"name\")\nH5Gclose(gid)\n\nH5Fclose(fid)\n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─script: \"## ----eval=FALSE---------------...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;int [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;int [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;dbl [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ ├─rhdf5-NA.OK: 1\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ └─software: \"SMARTIES=1.1, R=43.1, rhdf5=2.47.3\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "T-matrix",
    "section": "",
    "text": "Collection of scripts and self-contained examples to export/import T-matrices."
  },
  {
    "objectID": "index.html#examples-of-export-with-dummy-data",
    "href": "index.html#examples-of-export-with-dummy-data",
    "title": "T-matrix",
    "section": "Examples of export with dummy data",
    "text": "Examples of export with dummy data\n\nDoc: Julia • Script: export_julia.jl • Output: aj.tmat.h5\nDoc: Matlab • Script: export_matlab.m • Output: am.tmat.h5\nDoc: Python • Script: export_python.py • Output: ap.tmat.h5\nDoc: R • Script: export_R.R • Output: ar.tmat.h5"
  },
  {
    "objectID": "export_matlab.html",
    "href": "export_matlab.html",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "",
    "text": "This document showcases a basic Matlab script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_matlab.m."
  },
  {
    "objectID": "export_matlab.html#mockup-input-data",
    "href": "export_matlab.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe easyh5 library takes care of most of the details for us, when objects are stored in Matlab structures. There are a couple of caveats, illustrated below, such as polarization being handled separately, and attributes being added at a later stage.\n\n% possibly multiple wavelengths\nwavelength  = (400:50:800)';\nNl = length(wavelength);\n\nLmax = 3;\nqmax = 2*(Lmax*(Lmax+1)+Lmax); % T-matrix size\n\n% dummy 30x30 matrix values for each wavelength\n% note the transpose due to HDF5 expecting\n% row-major ordering vs matlab's default column-major\ntdata = transpose(reshape((1:qmax^2) + 1i*(1:qmax^2), [qmax,qmax]));\n\ntmatrix = zeros(Nl,qmax,qmax);\nfor i=1:Nl\n    tmatrix(i,:,:) = tdata;\nend\n\nsqueeze(tmatrix(1,1:3,1:3))\n\n% modes, but note that polarization is turned into strings separately\ni=1;\nfor l=1:3\n    for m=-l:l\n        for s=1:2\n            modes.l(i) = int64(l);\n            modes.m(i) = int64(m);\n            modes.s(i) = int64(s);\n            i=i+1;\n        end\n    end\nend\npolars = [\"electric\",\"magnetic\"];\npolarization = polars(modes.s);\nmodes = rmfield(modes,'s');\n\n% dummy 'analytical zeros' for e.g. EBCM methods\n% [zerosq, zerosqp] = ndgrid(1:2:30, 1:2:30);\n% zeros  = struct('q', zerosq, 'qp', zerosqp);\n\n% materials\nembedding = struct('relative_permeability', 1.0, ...\n                   'relative_permittivity', 1.33^2);\nparticle = struct('relative_permeability', 1.0, ...\n                  'relative_permittivity', repmat(-11.4+1.181i, [Nl,1]));\n\n% geometry\ngeometry = struct('radiusxy', 20.0, 'radiusz', 40.0);\n\nscatterer = struct('material', particle, ...\n                  'geometry', geometry);\n\n% details about computation\n\nmethod_parameters = struct('Lmax', int64(3), ...\n                           'Ntheta', int64(100));\n\ncomputation = struct('method_parameters', method_parameters);\n% 'analytical_zeros', zeros can be added here\n\nscript = convertCharsToStrings(fileread('export_matlab.m'));\n\n% combined (almost all) information into one struct\ns = struct('tmatrix', tmatrix, ...\n    'vacuum_wavelength', wavelength, ...\n    'embedding', embedding,...\n    'scatterer', scatterer, ...\n    'modes', modes, ...\n    'computation', computation);"
  },
  {
    "objectID": "export_matlab.html#saving-to-hdf5",
    "href": "export_matlab.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\n\naddpath(genpath('../easyh5/'));\n\nsaveh5 does most of the work, but we have to write polarization and script separately as strings within structs seem to trip easyh5.\n\nf = 'am.tmat.h5';\n[h5major,h5minor,h5rel] = H5.get_libversion(); % HDF5 version\nmatlabv = version ; % Matlab version\nsoftware = sprintf('SMARTIES=1.1, matlab=%s, HDF5=%d.%d.%d',matlabv,h5major,h5minor,h5rel);\n\nsaveh5(s, f, 'ComplexFormat', {'r','i'}, 'rootname', '', 'Compression', 'deflate'); \n\n% deal with string objects manually\nh5create(f,'/computation/files/script', size(script), 'Datatype', 'string')\nh5write(f,'/computation/files/script', script)\n\nh5create(f,'/modes/polarization', size(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\n\n% root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'storage_format_version', 'v0.01'); \nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz');\n\n% object and group attributes\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\n\nh5writeatt(f, '/embedding', 'keywords', 'non-dispersive');\nh5writeatt(f, '/embedding', 'name', 'H2O, Water');\n\nh5writeatt(f, '/scatterer/material', 'name', 'Au, Gold');\nh5writeatt(f, '/scatterer/material', 'reference', 'Au from Raschke et al 10.1103/PhysRevB.86.235147');\nh5writeatt(f, '/scatterer/material', 'keywords', 'dispersive, plasmonic');\n\nh5writeatt(f, '/scatterer/geometry', 'name', 'homogeneous spheroid with symmetry axis z');\nh5writeatt(f, '/scatterer/geometry', 'unit', 'nm');\nh5writeatt(f, '/scatterer/geometry', 'shape', 'spheroid')\n\nh5writeatt(f, '/computation', 'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids');\nh5writeatt(f, '/computation', 'name', 'SMARTIES');\nh5writeatt(f, '/computation', 'method', 'EBCM, Extended Boundary Condition Method');\nh5writeatt(f, '/computation', 'software', software);\n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─script: \"% possibly multiple wavelengths↵...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;int [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;int [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;dbl [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ └─software: \"SMARTIES=1.1, matlab=23.2.0.2380...\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  },
  {
    "objectID": "export_julia.html",
    "href": "export_julia.html",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "",
    "text": "This document showcases a basic Julia script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_julia.jl."
  },
  {
    "objectID": "export_julia.html#mockup-input-data",
    "href": "export_julia.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nFor convenience, we can store compound objects as named tuples, which will then be mapped into HDF5 groups during export.\n\n## mockup data\nusing Pkg, HDF5\n\n# possibly multiple wavelengths\nwavelength = collect(400:50:800)\nNl = length(wavelength)\nLmax = 3\nqmax = 2*(Lmax*(Lmax+1)+Lmax)\n\n# dummy 30x30 matrix values for each wavelength\n# note the row-major ordering\ntdata = transpose(reshape(collect(1:qmax^2) + collect(1:qmax^2) * 1im, (qmax,qmax)))\ntmatrix = zeros(ComplexF64,(Nl,qmax,qmax))\nfor i=1:Nl\n    tmatrix[i,:,:] = tdata\nend\n\nprint(tmatrix[1,1:3,1:3])\n\nl = zeros(Int64, qmax)\nm = zeros(Int64, qmax)\ns = Vector{String}(undef,qmax)\nlet\ni=1\nfor li = 1:Lmax\n    for mi = -li:li\n        for si = [\"electric\", \"magnetic\"]\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1\n        end\n    end\nend\nend"
  },
  {
    "objectID": "export_julia.html#saving-to-hdf5",
    "href": "export_julia.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nComplex arrays are stored with r and i fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we should therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language. Another potential source of error is that the HDF5.jl library orders the array data differently, compared to h5py.\n\nf = \"aj.tmat.h5\"\nver = Pkg.Operations.Context().env.manifest\nh5ver = string(ver[findfirst(v-&gt;v.name == \"HDF5\", ver)].version)\nsoftware = \"SMARTIES=1.1, julia=$(VERSION), HDF5.jl=$(h5ver)\"\n\nh5open(f, \"w\") do fid\n\n    fid[\"vacuum_wavelength\"] = wavelength\n    attributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\n\n    # set = permutedims(dset, reverse(1:ndims(dset)))\n    # https://juliaio.github.io/HDF5.jl/stable/#Language-interoperability-with-row-and-column-major-order-arrays\n    fid[\"tmatrix\"] = permutedims(tmatrix, reverse(1:ndims(tmatrix)))\n\n    modes = create_group(fid, \"modes\") \n    modes[\"l\"] = l\n    modes[\"m\"] = m\n    modes[\"polarization\"] = s\n\n    embedding = create_group(fid, \"embedding\") \n    embedding[\"relative_permittivity\"] = 1.33^2\n    embedding[\"relative_permeability\"] = 1.0\n    attributes(embedding)[\"name\"] = \"H2O, Water\"\n    attributes(embedding)[\"keywords\"] = \"non-dispersive\"\n\n    sca_mat = create_group(fid, \"scatterer/material\") \n    sca_mat[\"relative_permittivity\"] = repeat([-11.4 + 1.181im], Nl)\n    sca_mat[\"relative_permeability\"] = 1.0\n    attributes(sca_mat)[\"name\"] = \"Au, Gold\"\n    attributes(sca_mat)[\"keywords\"] = \"dispersive, plasmonic\"\n    attributes(sca_mat)[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n\n    sca_geo = create_group(fid, \"scatterer/geometry\") \n    sca_geo[\"radiusxy\"] = 20.0\n    sca_geo[\"radiusz\"] = 40.0\n    attributes(sca_geo)[\"unit\"] = \"nm\"\n    attributes(sca_geo)[\"shape\"] = \"spheroid\"\n    attributes(sca_geo)[\"name\"] = \"homogeneous spheroid with symmetry axis z\"\n\n    mpar = create_group(fid, \"computation/method_parameters\") \n    mpar[\"Lmax\"] = Lmax\n    mpar[\"Ntheta\"] = 100\n    script = create_group(fid, \"computation/files\") \n    script[\"script\"] = read(\"export_julia.jl\", String)\n    \n    # write root attributes\n    attributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\n    attributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\"    \n    attributes(fid)[\"storage_format_version\"] = \"v0.01\"\n    \n    # comp attributes\n    attributes(fid[\"computation\"])[\"method\"] = \"EBCM, Extended Boundary Condition Method\"\n    attributes(fid[\"computation\"])[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid[\"computation\"])[\"name\"] = \"SMARTIES\"\n    attributes(fid[\"computation\"])[\"software\"] = software\n\nend\n\n\nSummary of the file:\n&lt;list&gt;\n├─data: &lt;list&gt;\n│ ├─computation: &lt;list&gt;\n│ │ ├─files: &lt;list&gt;\n│ │ │ └─script: \"## mockup data↵using Pkg, HDF5↵↵...\"\n│ │ └─method_parameters: &lt;list&gt;\n│ │   ├─Lmax: 3\n│ │   └─Ntheta: 100\n│ ├─embedding: &lt;list&gt;\n│ │ ├─relative_permeability: 1\n│ │ └─relative_permittivity: 1.7689\n│ ├─modes: &lt;list&gt;\n│ │ ├─l&lt;int [30]&gt;: 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, ...\n│ │ ├─m&lt;int [30]&gt;: -1, -1, 0, 0, 1, 1, -2, -2, -1, -1, ...\n│ │ └─polarization&lt;chr [30]&gt;: \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", \"electric\", \"magnetic\", ...\n│ ├─scatterer: &lt;list&gt;\n│ │ ├─geometry: &lt;list&gt;\n│ │ │ ├─radiusxy: 20\n│ │ │ └─radiusz: 40\n│ │ └─material: &lt;list&gt;\n│ │   ├─relative_permeability: 1\n│ │   └─relative_permittivity&lt;cpl [9]&gt;: -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i, -11.4+1.181i\n│ ├─tmatrix&lt;cpl [8,100]&gt;: 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 1+1i, 31+31i, ...\n│ └─vacuum_wavelength&lt;int [9]&gt;: 400, 450, 500, 550, 600, 650, 700, 750, 800\n└─attributes: &lt;list&gt;\n  ├─root: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─keywords: \"gold, spheroid, ebcm, passive, r...\"\n  │ ├─name: \"Au prolate spheroid in water\"\n  │ └─storage_format_version: \"v0.01\"\n  ├─vacuum_wavelength: &lt;list&gt;\n  │ └─unit: \"nm\"\n  ├─computation: &lt;list&gt;\n  │ ├─description: \"Computation using SMARTIES, a nu...\"\n  │ ├─method: \"EBCM, Extended Boundary Conditio...\"\n  │ ├─name: \"SMARTIES\"\n  │ └─software: \"SMARTIES=1.1, julia=1.9.3, HDF5....\"\n  ├─embedding: &lt;list&gt;\n  │ ├─keywords: \"non-dispersive\"\n  │ └─name: \"H2O, Water\"\n  ├─material: &lt;list&gt;\n  │ ├─keywords: \"dispersive, plasmonic\"\n  │ ├─name: \"Au, Gold\"\n  │ └─reference: \"Au from Raschke et al 10.1103/Ph...\"\n  └─geometry: &lt;list&gt;\n    ├─name: \"homogeneous spheroid with symmet...\"\n    ├─shape: \"spheroid\"\n    └─unit: \"nm\""
  }
]